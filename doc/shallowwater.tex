% !TEX program = pdflatex

\documentclass[a4paper, sfsidenotes, twoside]{tufte-handout}

%\author{James Penn}
\title{A Shallow Water Model}


%\hypersetup{colorlinks}                               % use non-coloured hyperlinks
\urlstyle{sf}
\usepackage{lmodern}                                  % allow arbitrary size fonts
\usepackage[utf8]{inputenc}                           % allow UTF-8 formatting of source
\usepackage[english]{babel}                           % use English typesetting rules

\usepackage{MinionPro}                                % Adobe MinionPro Serif font
\usepackage{MyriadPro}                                % Adobe MyriadPro Sans-serif font

\usepackage{booktabs}                                 % nicely typeset tabular material
\usepackage{amsmath}                                  % basic maths
\usepackage{siunitx}                                  % SI unit formatting

\usepackage{graphicx}
\setkeys{Gin}{width=\linewidth,totalheight=\textheight,keepaspectratio}
\graphicspath{{images/}} % set of paths to search for images

\usepackage{minted}

% % bibliography
% \usepackage[square, numbers]{natbib}


\titleformat{\section}{\Large\sffamily}{\thesection}{1em}{}
\titleformat{\subsection}{\large\sffamily}{\thesubsection}{1em}{}

\input{jpcommands.tex}


\begin{document}

  \section{Introduction}
  \label{sec:Introduction}
  The Python code \texttt{linearshallowwater.py} models the linearised shallow
  water equations on the beta plane.
  \begin{marginfigure}[1in]
    \includegraphics{shallow_water}
    \caption{The Shallow Water Configuration}
    \label{fig:shallow}
  \end{marginfigure}
  These are
  \begin{subequations}
    \label{eqn:sw}
    \begin{align}
      \dd{u}{t} - fv &= - g \dd{h}{x} \\
      \dd{v}{t} + fu &= - g \dd{h}{y} \\
      \dd{h}{t} + H(\dd{u}{x} + \dd{v}{y}) &= 0
    \end{align}
  \end{subequations}
  where fluid height $\eta = H + h$ and Coriolis parameter $f=f_0 + \beta y$.

  The partial derivatives in space are approximated by a first-order central
  difference method and timestepping is performed using a linear-multistep method,
  the three-step Adams-Bashforth method.
  Appendix A \ref{sec:appendixa} details the numerical methods used.

  The code can be run on either Python 2 or Python 3, the only additional requirements are the libraries \texttt{numpy} and \texttt{matplotlib}.
  If you have not used Python on your computer before, you are unsure if you have the libraries, or if it's just been a long time since you used Python I recommend using one of the scientific distributions that are available to download.

  The two main choices are Enthought Canopy and Contiuum Anaconda.
  I use and recommend Anaconda; installing the latest version from the Continuum website \footnote{\url{https://www.continuum.io/downloads}} will give you the latest release of Python along with the most popular libraries \footnote{Notably \texttt{numpy}, \texttt{scipy}, \texttt{pandas}, \texttt{matplotlib}, \texttt{sympy} and \texttt{ipython}.  These six libraries will solve 99\% of your numerical, statistical and dataprocessing needs.
  A full list of included packages can be found at \url{http://docs.continuum.io/anaconda/pkg-docs}.}.
  Once the installer has been run, open a new terminal or command prompt window and you should have access to the new version of Python.

  A standard text editor such a Notepad is all that is required to edit the code, but not a \emph{word processor} like Microsoft Word.
  While Notepad is sufficient, there are many more powerful text editors available that make writing code a much more pleasant experience.
  Atom  \footnote{\url{https://atom.io/}} is a free, cross-platform option text editor with good support for Python.

  \section{Experiments}
  \label{sec:Experiments}

  \subsection{Experiment 1: Geostrophic Balance in 1-D}
  \label{sub:exp1}

  An introduction to the code.  By the end you will have run an example of geostrophic adjustment in one dimension and have an understanding of how the code can be changed.

  The first experiment demonstrates geostrophic adjustment in one dimension.
  There is no variation in the y-direction; the system that is being modelled is
  \begin{subequations}
    \begin{align}
      \dd{u}{t} &= fv - g \dd{h}{x} \\
      \dd{v}{t} &= -fu \\
      \dd{h}{t} &= -  H\dd{u}{x}
    \end{align}
  \end{subequations}
  Given some initial conditions and sensible values for $g$, $H$ and $f$ the system will be solved numerically.
  The intial conditions and constants are set
  \begin{align*}
    L_x &= \num{2e7} & H &= \num{100} & f &= \num{1e-5} & g &= \num{1} \\
    u_0 &= 0  & v_0 &= 0 & h_0 &= \tanh(100 \cdot x / L_x)
  \end{align*}
  and the code is allowed to evolve in time, taking a timestep $\Delta t = 1000$.
  \marginnote[-4em]{The code does not assume any units, but here the choice of constants scales the problem to be in [m] and [s].}
  \begin{itemize}
    \item Download the python script \texttt{linearshallowwater.py} from the
    course website \footnote{\url{http://empslocal.ex.ac.uk/people/staff/gv219/ecmm719/index.html}}.
    \textbf{If at any point you have changed several things, something goes really wrong and you can't get the code to run anymore, just go back to the course website and download a new copy.  You are encouraged to experiment and try new things!}
    \item Open a terminal (Mac/Linux) or command prompt (Windows), change directory to the location of the saved file and run it with the \texttt{python} command.
    \begin{minted}[mathescape]{bash}
      $ cd Downloads
      $ python linearshallowwater.py
    \end{minted}
    \begin{marginfigure}
      \includegraphics{geostrophy}
      \caption{A stepped height field undergoing geostrophic adjustment.}
      \label{fig:1dgeo}
    \end{marginfigure}
    \item The code should begin to run and an animation window will appear (Figure \ref{fig:1dgeo}).  If you can't see the chart check:
    \begin{itemize}
      \item That it is not hidden behind another window.  Sometimes the python plotting window can be opened behind your terminal or text editor window.
      \item That there are no errors on the command line.  If there are and you're not sure how to fix them, let me know.
    \end{itemize}
    \item Once you've got the code running, try changing some of the constants and see what happens.
    \begin{itemize}
      \item Set $f \gg \num{1e-5}$ and $f = \num{0.0}$.
      \begin{enumerate}
        \item What is happening in each of these cases?
        \item What happens to the gravity waves that radiate outwards?
        \item What is the problem with this numerical model compared with the analytic solution? \emph{Hint: boundary conditions.}
      \end{enumerate}
      \item If you want to see the simulation run longer, increase \texttt{nsteps} (found at around line \texttt{414}).
      \item (Advanced) The initial conditions for this experiment are set around line \texttt{315}.
      Try using a condition
      \begin{equation*}
        h_0 = \cos^n(\pi \cdot x / L_x)
      \end{equation*}
      where you can increase $n$ to get a more isolated hump.
    \end{itemize}
  \end{itemize}


  \subsection{Experiment 2: Geostrophic Adjustment in 2-D}
  \label{sub:exp2}
  We'll now consider the two-dimensional case where derivatives $\dd{}{y} \ne 0$ in general.
  So the system (\ref{eqn:sw}) will be solved in full.
  \begin{itemize}
    \item Make the following changes and run the code from the command line.
    \begin{minted}{python}
experiment = '2d'    # line 32
f0 = 0.0             # line 49
    \end{minted}
    \item You should see the case for a non-rotating fluid begin to run on
    your screen.  The height field is set with an initial condition of a small
    gaussian added to one point in the field.  As the equations evolve $u$ and
    $v$ velocities are induced and gravity waves radiate outwards from the initial disturbance.
    \begin{enumerate}
      \item Where on the Earth is $f_0 = 0$?
      \item (Advanced) What speed do you expect the gravity waves to be propagating at in this model?
    \end{enumerate}
    \begin{marginfigure}
      \includegraphics{gravity_waves}
      \caption{Gravity waves propagating away from an initial disturbance.}
      \label{fig:gravwaves}
    \end{marginfigure}
    \item Now try changing the Coriolis parameter to be something similar to that experienced in the mid-latitudes.
    \begin{enumerate}
      \item Change the value of $f_0$ back to $\num{1e-5}$ and rerun the two-dimensional case to compare with the irrotational version.
      \begin{enumerate}
        \item What happens to the gravity waves?
        \item What happens to the initial condition?
      \end{enumerate}
      \item Increase $f_0$ further.  What happens to the amplitude of the gravity waves as $f_0$ increases?
    \end{enumerate}
  \end{itemize}

\subsection{Advanced Experiments}
\label{sub:advanced}
  The code is quite versatile and capable of creating some other interesting dynamics.
  Here are a few more experiments you can try.
  These examples go beyond the scope of ECMM719; if you are interested further information of equatorial waves can be found in the Second Edition material for the Atmospheric and Oceanic Fluid Dynamics book under the section \emph{Waves on the Equatorial Beta Plane} \cite{Vallis:2015wb}.
    \begin{itemize}
      \item Coastal Kelvin Waves on the East Pacific coast.
      \begin{minted}{python}
Ly = 2.0e7                    # line 42
boundary_condition = 'walls'  # line 44
f0 = 0.0                      # line 49
beta =  2.0e-11               # line 50
      \end{minted}
      You may need to increase \texttt{nsteps} to see a longer simulation.

      As the initial height field decays, an \emph{equatorial Kelvin wave} moves Eastward.  When it reaches the boundary, it becomes a \emph{coastal Kelvin wave}.
    \item Equatorial Kelvin and Rossby waves.
          \begin{minted}{python}
boundary_condition = 'periodic'   # line 44
f0 = 0.0                          # line 49
beta =  2.0e-11                   # line 50
gr =  1.5e6                       # line 310
          \end{minted}
        \texttt{gr} specifies the radius of the disturbance in the height field.
        Here it is made bigger to be of order of the \emph{Rossby Deformation Radius} $L_d = \frac{\sqrt{gH}}{\beta}$.
      An equatorial Kelvin wave travels eastward along the equator, while two, slower moving, Rossby waves move westward in the tropics.
    \end{itemize}

  \section{Appendix A: Numerics}
  \label{sec:appendixa}

  \noindent The shallow water model uses finite difference methods to calculate
  the derivatives in the spatial dimension.

  In the simplest case, the domain $x \in [-L/2, L/2]$ is split into $N$
  subdivisions, creating $N+1$ \emph{nodes} of distance $\Delta x = L/(N+1)$ apart.
  We denote the positions of the nodes $x_0, x_1, ..., x_{N+1}$ where $x_j = j \Delta x$.

  For a continuous function $u(x)$ the definition of a derivative is
  \begin{equation}
    \dd{u}{x} = \lim_{\Delta x \to 0} \frac{u(x + \Delta x) - u(x)}{\Delta x}
  \end{equation}
  For our discrete model, at the node points $x_j$ described above we denote
  the value of $u_j = u(x_j)$ and simply approximate the derivative by considering
  only values at the closest node points
  \begin{equation}
    \label{eq:cendiff}
    \dd{u_j}{x} \simeq \frac{u_{j+1} - u_{j-1}}{2 \Delta x}
  \end{equation}
  This is the \emph{central difference} method of calculating a spatial derivative
  and is used extensively in this model.
  \begin{marginfigure}
    \includegraphics{cgrid}
    \caption{The Arakawa-C grid. From \citep{Arakawa:1981bx}}
    \label{fig:cgrid}
  \end{marginfigure}
  Obviously, an error has been introduced here for any function other than a
  straight line, the error is proportional to $\Delta x$.
  If $\Delta x$ is reduced ($N$ increases), error will be reduced but computing time will be
  increased as to calculate the value of $u(x)$ across the domain requires
  calculating the value at $(N+1)$ positions.
  The central-difference equation (\ref{eq:cendiff}) has a weakness - it is
  performed over a distance of $2 \Delta x$ and the new value at $u_i$ is
  decoupled from the previous value at this point as it depends solely on
  values at neighbouring nodes.

  For improved numerical stability, the locations of u, v and h values are
  staggered in a configuration known as the \emph{Arakawa-C grid} (Figure~\ref{fig:cgrid}).
  This distribution of value nodes means that, for example, the central difference
  approximation
  \begin{equation}
    \dd{h}{x} \simeq \frac{h_{i+1/2} - h_{i-1/2}}{\Delta x}
  \end{equation}
  falls at the location of the $u_i$ node.
  In the linearised shallow water equations this is a desirable property:
  the value of $u$ at the next timestep depends on $\dd{h}{x}$ and using
  the staggered configuration the dependency is on immediately adjacent values
  over a distance of $\Delta x$.

  Consider the other spatial derivative terms in the shallow water equations.
  How they can be approximated by a central difference method when using the
  Arakawa-C grid?


  In simulating the shallow water equations we are essentially solving
  an initial value problem.
  Once the spatial derviatives have been approximated the equations can
  be stepped forward in time in a similar manner to
  This idea can be extended to thinking about derivatives in time also.
  For example, the linear momentum equation can be discretised
  \begin{equation}
    \frac{u_j^{(n+1)} - u_j^{(n)}}{\Delta t} - fv_j^{(n)} = - \frac{\phi_{j+1}^{(n)} - \phi_{j-1}^{(n)}}{2 \Delta x}
  \end{equation}
  where $^{(n+1)}$ denotes the index in time in the same way $_j$ denotes
  index in space.

  This can be rearranged to calculate the value of $u_j^{(n+1)}$ entirely in
  terms of variables at the $^{(n)}$ time-level.
  \begin{equation}
    u_j^{(n+1)} = u_j^{(n)} + {\Delta t}
      \left( fv_j^{(n)} - \frac{\phi_{j+1}^{(n)} - \phi_{j-1}^{(n)}}{2 \Delta x} \right)
  \end{equation}
  Timestepping in this manner is known as \emph{Euler's method}.
  This is an \emph{explicit} numerical scheme as the value at time $^{(n+1)}$
  depends solely on values at $^{(n)}$.

  Euler's method is the simplest possible timestepping procedure,
  for better accuracy here the slightly more complicated three-step \emph{Adams-Bashforth}
  method is used for timestepping.  Adams-Bashforth $n$-step routines are a family
  of \emph{linear multistep} methods that calculate the state at the next timestep
  based on a weighted average of the states at the previous $n$ time levels.

  For a differential equation of the form $ \diff{y}{t} = f(t, y) $ the
  first three Adams-Bashforth multistep methods are
  \begin{align*}
    y_{n+1} &= y_n + \Delta t f(t_n, y_n)  \\
    y_{n+2} &= y_{n+1} + \Delta t \left( \frac{3}{2}f(t_{n+1}, y_{n+1}) - \frac{1}{2}f(t_n, y_n) \right) \\
    y_{n+3} &= y_{n+2} + \Delta t \left( \frac{23}{12} f(t_{n+2}, y_{n+2}) - \frac{4}{3} f(t_{n+1}, y_{n+1}) + \frac{5}{12}f(t_n, y_n)\right) \\
  \end{align*}
  For a comprehensive (and rigorous!) discussion of numerical methods in
  geophysical fluids problems see Dale Durran's book \cite{Durran:2010hy}.


\bibliography{biblio}
\bibliographystyle{plainnat}

\end{document}
